gcc *.c *.h -lreadline  

gerer en priorite les $ rapelle en "" ou normak mais pas ne ''
cherhcer dans env si valeur donne 
"" = 34;
' = 39;

counter - coutner len - coumter

				value = malloc(sizeof(char) * strlen(env) - strlen(str) + 1);
				c = 0;
				while (env[i++] != '\0')
				{
					printf("%c", env[i]);
					value[c] = env[i];
					c++;
				}

SRC =	$(SRC_DIR)/main.c			\
		$(SRC_DIR)/utils.c			\
		$(SRC_DIR)/token.c			\
		$(SRC_DIR)/split.c		\


/*char	*get_cmdr(char *cmd, t_token *token)
{
	int		i;
	int		c;
	int		k;
	char	*str;

	i = 0;
	c = 0;
	token->start_arg = 0;
	while (cmd[i] != '\0')
	{
		while (cmd[i] == ' ')
			i++;
		if (cmd[i] != 34 && cmd[i] != 39 && cmd[i] != '<' && cmd[i] != '>'
			&& cmd[i] != '-' && (cmd[i] < 'a' || cmd[i] > 'z') && (cmd[i] < '0'
				|| cmd[i] > '9'))
		{
			return (NULL);
		}
		k = i;
		while ((cmd[i + c] != '\0' && (cmd[i + c] != ' ')))
            {
                //printf("valeur de retour %d && %d\n", check_in_quote(cmd, i + c), cmd[i+c]);
                //if (cmd[i + c] == ' ' && check_in_quote(cmd, i + c) == -1)
                c++;
            }
			
		break ;
	}
	i = 0;
	printf("valeur : %d\n", c);
	str = malloc(sizeof(char) * c + 1);
	while (i < c)
		str[i++] = cmd[k++];
	str[i] = '\0';
    str = ft_remove_quote(str, 0);
    printf("la string %s\n", str);
	token->start_arg = 0;
	return (str);
}*/


char	**put_arg(char **lexer, t_token *token)
{
	int		i;
    int     c;

	i = 0;
	c = 0;
	while (token->arg[i] != 0)
	{
		if (strcmp(token->arg[i], "<") == 0 || strcmp(token->arg[i], ">") == 0
			|| strcmp(token->arg[i], ">>") == 0 || strcmp(token->arg[i], "<<") == 0)
                c++;
        i++;
	}    
    printf("le malloc serait de %d\n", i - (c * 2) + 1);

    lexer = malloc(sizeof(char *) * i - (c * 2) + 1);
    if (!lexer)
        return (NULL);
    
}













#include <minishell.h>

char	*swap_value(char *str, char *value, char *env)
{
	char *new;
	int i;
	int k;

	i = 0;
	new = malloc(sizeof(char) * ft_strlen(env) + (ft_strlen(str) - ft_strlen(value)) + 1);
	if (!new)
		return(NULL);
	while (str[i] != '$' && check_in_quote(str, i) == -1)
		i++;
	new = ft_strlcpy(new,str,i + 1);
	new = ft_strjoin(new,env);
	new = ft_strnjoin(new, str, i + 1 + ft_strlen(value));
	return (new);
	
	
}

char *	get_expand(char *value, char **envp, char *str)
{
	int i;
	char *dest;
	int c;
	int k;

	i = 0;
	c = 0;
	k = 0;
	while (envp[i] != 0)
	{
		if (strncmp(value,envp[i],ft_strlen(value)) == 0  && envp[i][ft_strlen(value)] == '=')
		{
			c = ft_strlen(value) + 1;
			dest = malloc(sizeof(char ) * (ft_strlen(envp[i]) - ft_strlen(value) + 1)); // por gratter ligne faire une foction qui malloc a la place de celle -ci
			if (!dest)
				return (NULL);
			while (envp[i][c] != '\0')
				dest[k++] = envp[i][c++]; 
		}
		i++;
	}
	dest[k] = '\0';
	str = swap_value(str,value,dest);
	return (str);
}

char	*get_value(char *str, char *value)
{
	int i;
	int c;

	i = 0;
	c = 0;
	while (str[i++] != '\0')
	{
		if (str[i] == '$' && check_in_quote(str, i) == -1)
		{
			i++;
			while (str[i] != ' ' && str[i] != '\0' && (str[i] < '0' || str[i] > '9') && str[i] != '$')
			{
				value[c++] = str[i++];
			}
		}
	}
	value[c] = '\0';
	return (value);
}

char	*ft_dollars(char *str, char **envp)
{
	int i;
	int c;
	char *value;

	i = 0;
	c = 0;
	while (str[i++] != '\0')
	{
		if (str[i] == '$' && check_in_quote(str,i) == -1)
		{
			i++; 
			while (str[i] != ' ' && str[i] != '\0' && (str[i] < '0' || str[i] > '9') && str[i] != '$')
			{
				c++;
				i++;
			}
		}
	}
	if (c == 0)
		return (str);
	value = malloc(sizeof(char) * c + 1);
	if (!value)
		return (NULL);
	value = get_value(str,value);
	return (get_expand(value,envp,str));
}